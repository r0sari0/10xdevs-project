# Database Schema: AI Flashcard Generator

## 1. Tables

### Custom Types

First, we define a custom ENUM type to represent the origin of a flashcard.

```sql
CREATE TYPE flashcard_source AS ENUM ('ai-full', 'ai-edited', 'manual');
```

### Table: `generations`

This table stores metadata related to each AI flashcard generation process.

```sql
CREATE TABLE generations (
    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    model VARCHAR(255) NOT NULL,
    generated_count INT NOT NULL,
    accepted_unedited_count INT NOT NULL DEFAULT 0,
    accepted_edited_count INT NOT NULL DEFAULT 0,
    source_text_hash VARCHAR(64) NOT NULL,
    source_text_length INT NOT NULL CHECK (source_text_length >= 1000 AND source_text_length <= 10000),
    generation_duration INT NOT NULL, -- in milliseconds
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
```

### Table: `flashcards`

This table contains all flashcards, whether created manually or generated by AI.

```sql
CREATE TABLE flashcards (
    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    generation_id BIGINT NULL REFERENCES generations(id) ON DELETE CASCADE,
    front VARCHAR(200) NOT NULL,
    back VARCHAR(500) NOT NULL,
    source flashcard_source NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
```

### Table: `generation_error_logs`

This table will store logs of errors that occur during the AI generation process.

```sql
CREATE TABLE generation_error_logs (
    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    model VARCHAR(255) NOT NULL,
    source_text_hash VARCHAR(64) NOT NULL,
    source_text_length INT NOT NULL CHECK (source_text_length >= 1000 AND source_text_length <= 10000),
    error_code VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
```

## 2. Relationships

-   **`auth.users` <-> `generations`**: One-to-Many. A user can have many generation records. The relationship is enforced by the `user_id` foreign key.
-   **`auth.users` <-> `flashcards`**: One-to-Many. A user can have many flashcards. The relationship is enforced by the `user_id` foreign key.
-   **`generations` <-> `flashcards`**: One-to-Many. A single generation process can produce multiple flashcards. This is an optional relationship, as manually created flashcards will have a `NULL` `generation_id`.
-   **`auth.users` <-> `generation_error_logs`**: One-to-Many. A user can have many generation error logs. The relationship is enforced by the `user_id` foreign key.

All relationships use `ON DELETE CASCADE` to ensure that when a user is deleted from `auth.users`, all their associated data (`generations`, `flashcards`, and `generation_error_logs`) is automatically removed, maintaining data integrity.

## 3. Indexes

To optimize query performance, especially for fetching data specific to a user, the following indexes will be created:

```sql
-- Index for fetching all generations for a specific user
CREATE INDEX idx_generations_user_id ON generations(user_id);

-- Index for fetching all flashcards for a specific user
CREATE INDEX idx_flashcards_user_id ON flashcards(user_id);

-- Index for fetching all flashcards from a specific generation
CREATE INDEX idx_flashcards_generation_id ON flashcards(generation_id);

-- Index for fetching all error logs for a specific user
CREATE INDEX idx_generation_error_logs_user_id ON generation_error_logs(user_id);
```

## 4. Row Level Security (RLS)

To ensure users can only access their own data, Row Level Security (RLS) will be enabled on the `generations`, `flashcards`, and `generation_error_logs` tables.

### Enable RLS

```sql
ALTER TABLE generations ENABLE ROW LEVEL SECURITY;
ALTER TABLE flashcards ENABLE ROW LEVEL SECURITY;
ALTER TABLE generation_error_logs ENABLE ROW LEVEL SECURITY;
```

### RLS Policies

```sql
-- Policy for the 'generations' table
CREATE POLICY "Users can access their own generation records"
ON generations FOR ALL
USING (auth.uid() = user_id);

-- Policy for the 'flashcards' table
CREATE POLICY "Users can access their own flashcards"
ON flashcards FOR ALL
USING (auth.uid() = user_id);

-- Policy for the 'generation_error_logs' table
CREATE POLICY "Users can access their own generation error logs"
ON generation_error_logs FOR ALL
USING (auth.uid() = user_id);
```

## 5. Additional Considerations

### Automating `updated_at`

To automatically update the `updated_at` timestamp on row modification, a trigger function will be used. This resolves one of the open points from the planning session.

```sql
-- 1. Create the function
CREATE OR REPLACE FUNCTION handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 2. Create the triggers for each table
CREATE TRIGGER on_generations_update
BEFORE UPDATE ON generations
FOR EACH ROW EXECUTE PROCEDURE handle_updated_at();

CREATE TRIGGER on_flashcards_update
BEFORE UPDATE ON flashcards
FOR EACH ROW EXECUTE PROCEDURE handle_updated_at();
```

### Hashing Algorithm

The specific algorithm for generating the `source_text_hash` in the `generations` table has not been finalized. A common and secure choice would be **SHA-256**, which produces a 64-character hexadecimal string. The `VARCHAR(64)` type is suitable for this. This decision should be confirmed and implemented in the application logic.
